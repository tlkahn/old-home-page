// Generated by CoffeeScript 1.3.3
(function() {
  var Tetris,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Tetris = (function() {

    function Tetris(width, height) {
      this.width = width;
      this.height = height;
      this.array = this.array_factory();
      this.mid = Math.floor(this.width / 2);
      this.wedge = [this.mid, this.mid + this.width, this.mid + this.width - 1, this.mid + this.width + 1];
      this.square = [this.mid, this.mid + 1, this.mid + this.width, this.mid + this.width + 1];
      this.stick = [this.mid, this.mid + this.width, this.mid + this.width + 1, this.mid + this.width + 2];
      this.spear = [this.mid, this.mid + this.width, this.mid + 2 * this.width, this.mid + 3 * this.width];
      this.twist = [this.mid, this.mid + this.width, this.mid + this.width + 1, this.mid + this.width + 1 + this.width];
      this.tetris_block = [this.wedge, this.square, this.stick, this.twist, this.spear];
      this.current_rotation_code = 0;
      this.current_block_type = this.block_type_factory();
      this.current_block = this.current_block_factory();
      this.dead_block = [];
      this.current_score = 0;
      this.next_block_type = this.block_type_factory();
      this.next_block = this.next_block_factory();
    }

    Tetris.prototype.reset = function() {
      this.array = this.array_factory;
      this.current_rotation_code = 0;
      this.current_block_type = this.block_type_factory();
      this.current_block = this.current_block_factory();
      this.next_block_type = this.block_type_factory();
      this.next_block = this.next_block_factory();
      return this.dead_block = [];
    };

    Tetris.prototype.get_array = function() {
      return this.array;
    };

    Tetris.prototype.get_deadblock = function() {
      var i, item;
      this.dead_block = (function() {
        var _i, _len, _ref, _results;
        _ref = this.array;
        _results = [];
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          item = _ref[i];
          if (item === 2) {
            _results.push(i);
          }
        }
        return _results;
      }).call(this);
      return this.dead_block;
    };

    Tetris.prototype.array_factory = function() {
      var item;
      return this.array = (function() {
        var _i, _ref, _results;
        _results = [];
        for (item = _i = 0, _ref = this.width * this.height; 0 <= _ref ? _i < _ref : _i > _ref; item = 0 <= _ref ? ++_i : --_i) {
          _results.push(0);
        }
        return _results;
      }).call(this);
    };

    Tetris.prototype.block_type_factory = function() {
      return Math.floor(Math.random() * this.tetris_block.length);
    };

    Tetris.prototype.current_block_factory = function() {
      return this.tetris_block[this.current_block_type];
    };

    Tetris.prototype.next_block_factory = function() {
      return this.tetris_block[this.next_block_type];
    };

    Tetris.prototype.to_s = function() {
      var array_item, _i, _len, _ref, _results;
      _ref = this.array;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        array_item = _ref[_i];
        _results.push(array_item);
      }
      return _results;
    };

    Tetris.prototype.clean = function() {
      var item, _i, _len, _ref, _results;
      this.array_factory();
      _ref = this.dead_block;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        _results.push(this.array[item] = 2);
      }
      return _results;
    };

    Tetris.prototype.scan_killable_lines = function() {
      var i, j, result, s, _i, _j, _ref, _ref1, _ref2;
      result = [];
      s = 0;
      for (i = _i = 0, _ref = this.height; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        for (j = _j = _ref1 = i * this.width, _ref2 = (i + 1) * this.width; _ref1 <= _ref2 ? _j < _ref2 : _j > _ref2; j = _ref1 <= _ref2 ? ++_j : --_j) {
          if (__indexOf.call(this.get_deadblock(), j) >= 0) {
            s += 2;
          }
        }
        if (s === 2 * this.width) {
          this.current_score += 10;
          result.push(i);
        }
        s = 0;
      }
      return result;
    };

    Tetris.prototype.kill_lines = function(lines) {
      var i, index, item, j, k, value, _i, _j, _len, _ref, _ref1, _ref2, _results;
      _results = [];
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        i = lines[_i];
        for (j = _j = _ref = i * this.width, _ref1 = (i + 1) * this.width; _ref <= _ref1 ? _j < _ref1 : _j > _ref1; j = _ref <= _ref1 ? ++_j : --_j) {
          this.array[j] = 0;
          _ref2 = this.dead_block;
          for (index in _ref2) {
            value = _ref2[index];
            if (value === j) {
              this.dead_block.splice(index, 1);
            }
          }
        }
        _results.push((function() {
          var _k, _ref3, _results1;
          _results1 = [];
          for (k = _k = _ref3 = i * this.width - 1; _k >= 0; k = _k += -1) {
            _results1.push((function() {
              var _l, _len1, _ref4, _results2;
              _ref4 = this.dead_block;
              _results2 = [];
              for (index = _l = 0, _len1 = _ref4.length; _l < _len1; index = ++_l) {
                item = _ref4[index];
                if (item === k) {
                  this.dead_block[index] += this.width;
                  this.array[k] = 0;
                  _results2.push(this.array[k + this.width] = 2);
                } else {
                  _results2.push(void 0);
                }
              }
              return _results2;
            }).call(this));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Tetris.prototype.block_move_down = function() {
      var item;
      return this.current_block = (function() {
        var _i, _len, _ref, _results;
        _ref = this.current_block;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          _results.push(item + this.width);
        }
        return _results;
      }).call(this);
    };

    Tetris.prototype.block_move_left = function() {
      var item;
      if (!this.touch_left_wall()) {
        return this.current_block = (function() {
          var _i, _len, _ref, _results;
          _ref = this.current_block;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            item = _ref[_i];
            _results.push(item - 1);
          }
          return _results;
        }).call(this);
      }
    };

    Tetris.prototype.block_move_right = function() {
      var item;
      if (!this.touch_right_wall()) {
        return this.current_block = (function() {
          var _i, _len, _ref, _results;
          _ref = this.current_block;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            item = _ref[_i];
            _results.push(item + 1);
          }
          return _results;
        }).call(this);
      }
    };

    Tetris.prototype.rotate = function() {
      this.current_rotation_code = (this.current_rotation_code + 1) % 4;
      switch (this.current_block_type) {
        case 0:
          return this.wedge_rotate();
        case 1:
          return this.square_rotate();
        case 2:
          return this.stick_rotate();
        case 3:
          return this.twist_rotate();
        case 4:
          return this.spear_rotate();
        default:
          return console.log("error in find block type");
      }
    };

    Tetris.prototype.wedge_rotate = function() {
      var i, j, _ref, _ref1;
      switch (this.current_rotation_code) {
        case 1:
          if (this.touch_bottom()) {
            this.current_rotation_code -= 1;
          } else {
            return this.current_block[2] = this.current_block[1] + this.width;
          }
          break;
        case 2:
          if (__indexOf.call((function() {
            var _i, _len, _ref, _results;
            _ref = (function() {
              var _j, _len, _ref, _results1;
              _ref = this.current_block.slice(0, 3);
              _results1 = [];
              for (_j = 0, _len = _ref.length; _j < _len; _j++) {
                i = _ref[_j];
                _results1.push(i - 1);
              }
              return _results1;
            }).call(this);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              j = _ref[_i];
              _results.push(this.array[j]);
            }
            return _results;
          }).call(this), 2) >= 0) {
            this.current_rotation_code -= 1;
          } else {
            return this.current_block[0] = this.current_block[1] - 1;
          }
          break;
        case 3:
          return this.current_block[3] = this.current_block[1] - this.width;
        case 0:
          if (__indexOf.call((function() {
            var _i, _len, _ref, _results;
            _ref = (function() {
              var _j, _len, _ref, _results1;
              _ref = this.current_block.slice(1, 4);
              _results1 = [];
              for (_j = 0, _len = _ref.length; _j < _len; _j++) {
                i = _ref[_j];
                _results1.push(i + 1);
              }
              return _results1;
            }).call(this);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              j = _ref[_i];
              _results.push(this.array[j]);
            }
            return _results;
          }).call(this), 2) >= 0) {
            this.current_rotation_code -= 1;
          } else {
            this.current_block[2] = this.current_block[1] + 1;
            _ref = [this.current_block[3], this.current_block[0]], this.current_block[0] = _ref[0], this.current_block[3] = _ref[1];
            return _ref1 = [this.current_block[3], this.current_block[2]], this.current_block[2] = _ref1[0], this.current_block[3] = _ref1[1], _ref1;
          }
      }
    };

    Tetris.prototype.square_rotate = function() {};

    Tetris.prototype.stick_rotate = function() {
      var i, j;
      switch (this.current_rotation_code) {
        case 1:
          if (this.touch_bottom()) {
            this.current_rotation_code -= 1;
          } else {
            this.current_block[3] = this.current_block[0] + 1;
            return this.current_block[2] = this.current_block[1] + this.width;
          }
          break;
        case 2:
          if (__indexOf.call((function() {
            var _i, _len, _ref, _results;
            _ref = (function() {
              var _j, _len, _ref, _results1;
              _ref = this.current_block.slice(0, 3);
              _results1 = [];
              for (_j = 0, _len = _ref.length; _j < _len; _j++) {
                i = _ref[_j];
                _results1.push(i - 1);
              }
              return _results1;
            }).call(this);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              j = _ref[_i];
              _results.push(this.array[j]);
            }
            return _results;
          }).call(this), 2) >= 0 || (this.current_block[0] % this.width < 2)) {
            this.current_rotation_code -= 1;
          } else {
            this.current_block[2] = this.current_block[0] - 1;
            return this.current_block[3] = this.current_block[2] - 1;
          }
          break;
        case 3:
          if (__indexOf.call((function() {
            var _i, _len, _ref, _results;
            _ref = (function() {
              var _j, _len, _ref, _results1;
              _ref = this.current_block.slice(0, 4);
              _results1 = [];
              for (_j = 0, _len = _ref.length; _j < _len; _j++) {
                i = _ref[_j];
                _results1.push(i + 1);
              }
              return _results1;
            }).call(this);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              j = _ref[_i];
              _results.push(this.array[j]);
            }
            return _results;
          }).call(this), 2) >= 0) {
            this.current_rotation_code -= 1;
          } else {
            this.current_block[1] = this.current_block[0] + 1;
            this.current_block[2] = this.current_block[1] - this.width;
            return this.current_block[3] = this.current_block[2] - this.width;
          }
          break;
        case 0:
          if (this.touch_bottom() || __indexOf.call((function() {
            var _i, _len, _ref, _results;
            _ref = (function() {
              var _j, _len, _ref, _results1;
              _ref = this.current_block.slice(0, 4);
              _results1 = [];
              for (_j = 0, _len = _ref.length; _j < _len; _j++) {
                i = _ref[_j];
                _results1.push(i + 1);
              }
              return _results1;
            }).call(this);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              j = _ref[_i];
              _results.push(this.array[j]);
            }
            return _results;
          }).call(this), 2) >= 0 || (this.current_block[1] % this.width === (this.width - 1))) {
            this.current_rotation_code -= 1;
          } else {
            this.current_block[1] = this.current_block[0] + this.width;
            this.current_block[2] = this.current_block[1] + 1;
            return this.current_block[3] = this.current_block[2] + 1;
          }
      }
    };

    Tetris.prototype.twist_rotate = function() {
      var i, j;
      switch (this.current_rotation_code) {
        case 1:
          if (__indexOf.call((function() {
            var _i, _len, _ref, _results;
            _ref = (function() {
              var _j, _len, _ref, _results1;
              _ref = this.current_block.slice(0, 2);
              _results1 = [];
              for (_j = 0, _len = _ref.length; _j < _len; _j++) {
                i = _ref[_j];
                _results1.push(i + this.width);
              }
              return _results1;
            }).call(this);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              j = _ref[_i];
              _results.push(this.array[j]);
            }
            return _results;
          }).call(this), 2) >= 0) {
            this.current_rotation_code -= 1;
          } else {
            this.current_block[3] = this.current_block[1] + this.width;
            return this.current_block[0] = this.current_block[3] - 1;
          }
          break;
        case 2:
          this.current_block[0] = this.current_block[1] - this.width;
          return this.current_block[3] = this.current_block[2] + this.width;
        case 3:
          if (__indexOf.call((function() {
            var _i, _len, _ref, _results;
            _ref = (function() {
              var _j, _len, _ref, _results1;
              _ref = this.current_block.slice(0, 2);
              _results1 = [];
              for (_j = 0, _len = _ref.length; _j < _len; _j++) {
                i = _ref[_j];
                _results1.push(i + this.width);
              }
              return _results1;
            }).call(this);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              j = _ref[_i];
              _results.push(this.array[j]);
            }
            return _results;
          }).call(this), 2) >= 0) {
            this.current_rotation_code -= 1;
          } else {
            this.current_block[3] = this.current_block[1] + this.width;
            return this.current_block[0] = this.current_block[3] - 1;
          }
          break;
        case 0:
          this.current_block[0] = this.current_block[1] - this.width;
          return this.current_block[3] = this.current_block[2] + this.width;
      }
    };

    Tetris.prototype.spear_rotate = function() {
      var i, j;
      switch (this.current_rotation_code) {
        case 1:
          if ((__indexOf.call((function() {
            var _i, _len, _ref, _results;
            _ref = (function() {
              var _j, _len, _ref, _results1;
              _ref = this.current_block.slice(0, 4);
              _results1 = [];
              for (_j = 0, _len = _ref.length; _j < _len; _j++) {
                i = _ref[_j];
                _results1.push(i + 1);
              }
              return _results1;
            }).call(this);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              j = _ref[_i];
              _results.push(this.array[j]);
            }
            return _results;
          }).call(this), 2) >= 0) || (__indexOf.call((function() {
            var _i, _len, _ref, _results;
            _ref = (function() {
              var _j, _len, _ref, _results1;
              _ref = this.current_block.slice(0, 4);
              _results1 = [];
              for (_j = 0, _len = _ref.length; _j < _len; _j++) {
                i = _ref[_j];
                _results1.push(i - 1);
              }
              return _results1;
            }).call(this);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              j = _ref[_i];
              _results.push(this.array[j]);
            }
            return _results;
          }).call(this), 2) >= 0) || (this.current_block[0] % this.width < 2) || (this.current_block[0] % this.width === (this.width - 1))) {
            this.current_rotation_code -= 1;
          } else {
            this.current_block[1] = this.current_block[2] - 1;
            this.current_block[0] = this.current_block[1] - 1;
            return this.current_block[3] = this.current_block[2] + 1;
          }
          break;
        case 2:
          if (this.touch_bottom()) {
            this.current_rotation_code -= 1;
          } else {
            this.current_block[1] = this.current_block[2] - this.width;
            this.current_block[0] = this.current_block[1] - this.width;
            return this.current_block[3] = this.current_block[2] + this.width;
          }
          break;
        case 3:
          if ((__indexOf.call((function() {
            var _i, _len, _ref, _results;
            _ref = (function() {
              var _j, _len, _ref, _results1;
              _ref = this.current_block.slice(0, 4);
              _results1 = [];
              for (_j = 0, _len = _ref.length; _j < _len; _j++) {
                i = _ref[_j];
                _results1.push(i + 1);
              }
              return _results1;
            }).call(this);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              j = _ref[_i];
              _results.push(this.array[j]);
            }
            return _results;
          }).call(this), 2) >= 0) || (__indexOf.call((function() {
            var _i, _len, _ref, _results;
            _ref = (function() {
              var _j, _len, _ref, _results1;
              _ref = this.current_block.slice(0, 4);
              _results1 = [];
              for (_j = 0, _len = _ref.length; _j < _len; _j++) {
                i = _ref[_j];
                _results1.push(i - 1);
              }
              return _results1;
            }).call(this);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              j = _ref[_i];
              _results.push(this.array[j]);
            }
            return _results;
          }).call(this), 2) >= 0) || (this.current_block[0] % this.width < 2) || (this.current_block[0] % this.width === (this.width - 1))) {
            this.current_rotation_code -= 1;
          } else {
            this.current_block[1] = this.current_block[2] - 1;
            this.current_block[0] = this.current_block[1] - 1;
            return this.current_block[3] = this.current_block[2] + 1;
          }
          break;
        case 0:
          if (this.touch_bottom()) {
            this.current_rotation_code -= 1;
          } else {
            this.current_block[1] = this.current_block[2] - this.width;
            this.current_block[0] = this.current_block[1] - this.width;
            return this.current_block[3] = this.current_block[2] + this.width;
          }
      }
    };

    Tetris.prototype.show_block = function() {
      var item, _i, _len, _ref, _results;
      _ref = this.current_block;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        _results.push(this.array[item] = 1);
      }
      return _results;
    };

    Tetris.prototype.touch_left_wall = function() {
      var item, _i, _len, _ref;
      _ref = this.current_block;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if ((item % this.width) === 0 || this.array[item - 1] === 2) {
          return true;
        }
      }
      return false;
    };

    Tetris.prototype.touch_right_wall = function() {
      var item, _i, _len, _ref;
      _ref = this.current_block;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (item % this.width === (this.width - 1) || this.array[item + 1] === 2) {
          return true;
        }
      }
      return false;
    };

    Tetris.prototype.touch_bottom = function() {
      var item, _i, _len, _ref;
      _ref = this.current_block;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (item >= (this.width * (this.height - 1))) {
          return true;
        }
      }
      return false;
    };

    Tetris.prototype.solidify = function() {
      var item, _i, _len, _ref, _results;
      _ref = this.current_block;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        _results.push(this.dead_block.push(item));
      }
      return _results;
    };

    Tetris.prototype.generate_another_block = function() {
      this.current_block_type = this.next_block_type;
      this.current_block = this.next_block;
      this.next_block_type = this.block_type_factory();
      this.next_block = this.next_block_factory();
      if (this.touch_dead_block()) {
        alert("game over!");
        return false;
      } else {
        this.current_rotation_code = 0;
        return true;
      }
    };

    Tetris.prototype.clear_current_block = function() {
      var item, _i, _len, _ref;
      _ref = this.current_block;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        this.array[item] = 0;
      }
      return this.current_block = [];
    };

    Tetris.prototype.touch_dead_block = function() {
      var item, _i, _len, _ref;
      _ref = this.current_block;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (this.array[item + this.width] === 2) {
          return true;
        }
      }
      return false;
    };

    return Tetris;

  })();

  $(function() {
    var down, draw_next_block, left, pause, pause_status, refresh, resume, right, rotate, t, timer;
    t = new Tetris(10, 20);
    refresh = function() {
      var cell_css, item, jtem, n, row, table, _i, _j, _ref, _ref1;
      row = "";
      table = "";
      for (item = _i = 0, _ref = t.height; 0 <= _ref ? _i < _ref : _i > _ref; item = 0 <= _ref ? ++_i : --_i) {
        table = table + "<tr>";
        for (jtem = _j = 0, _ref1 = t.width; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; jtem = 0 <= _ref1 ? ++_j : --_j) {
          n = jtem + item * t.width;
          if (t.array[n] === 1) {
            cell_css = 'block';
          } else if (t.array[n] === 2) {
            cell_css = 'dead_block';
          } else {
            cell_css = 'cell';
          }
          row = row + ("<td class=" + cell_css + " id=" + n + ">&nbsp&nbsp&nbsp&nbsp</td>");
        }
        table = table + row + "</tr>";
        row = "";
      }
      $("#frame").html("<table>" + table + "</table>");
      $("#score").html(t.current_score);
      return draw_next_block();
    };
    draw_next_block = function() {
      var i, item, j, table, _i, _j, _k, _len, _ref, _ref1, _results;
      table = "<table style='border-style:none'>";
      for (i = _i = 0; _i < 4; i = ++_i) {
        table += "<tr>";
        for (j = _j = 0, _ref = t.width; 0 <= _ref ? _j < _ref : _j > _ref; j = 0 <= _ref ? ++_j : --_j) {
          table += "<td id=n" + (i * t.width + j) + ">&nbsp&nbsp&nbsp&nbsp</td>";
        }
        table += "</tr>";
      }
      table += "</table>";
      $("#next_block").html(table);
      _ref1 = t.next_block;
      _results = [];
      for (_k = 0, _len = _ref1.length; _k < _len; _k++) {
        item = _ref1[_k];
        _results.push($("#n" + item).addClass("block"));
      }
      return _results;
    };
    down = function() {
      if (t.touch_bottom() || t.touch_dead_block()) {
        t.solidify();
        t.clear_current_block();
        if (!t.generate_another_block()) {
          t.reset();
        } else {
          t.clean();
        }
      } else {
        t.clean();
        t.block_move_down();
      }
      t.kill_lines(t.scan_killable_lines());
      t.show_block();
      return refresh();
    };
    left = function() {
      if (!t.touch_left_wall()) {
        t.clean();
        t.block_move_left();
        t.show_block();
        return refresh();
      }
    };
    right = function() {
      if (!t.touch_right_wall()) {
        t.clean();
        t.block_move_right();
        t.show_block();
        return refresh();
      }
    };
    rotate = function() {
      t.clean();
      t.rotate();
      t.show_block();
      return refresh();
    };
    pause_status = 0;
    $(document).keydown(function(e) {
      switch (e.which) {
        case 37:
          if (pause_status === 0) {
            left();
          }
          break;
        case 38:
          if (pause_status === 0) {
            rotate();
          }
          break;
        case 39:
          if (pause_status === 0) {
            right();
          }
          break;
        case 40:
          if (pause_status === 0) {
            down();
          }
          break;
        case 32:
          if (pause_status === 0) {
            pause();
          } else {
            resume();
          }
          pause_status = ~pause_status;
          break;
        default:
          return;
      }
      return e.preventDefault();
    });
    t.clean();
    t.show_block();
    refresh();
    timer = setInterval(down, 1000);
    pause = function() {
      return clearInterval(timer);
    };
    return resume = function() {
      return timer = setInterval(down, 1000);
    };
  });

}).call(this);
